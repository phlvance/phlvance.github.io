<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>阿飞的博客  | Collection体系和常用实现类</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.58.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Collection体系和常用实现类" />
<meta property="og:description" content="Collection体系和常用实现类  Collection继承体系  // 常用实现: ArrayList List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i&lt; list.size(); i&#43;&#43;) { list.get(i); }  // 常用实现: LinkedHashSet Collect c = new LinkedHashSet(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(c); //等价于 List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); list2.addAll(c); //等价于 List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(); for(Integer i : c){ list3.add(i); } list.add(1); list.add(2); //不停的加  List  最常用的ArrayList  本质上是一个数组  面试题: 动态扩容的实现  创建一个更大的空间, 然后把原先的所有元素拷贝过去    旧的容量=数组的长度" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://afei.website/posts/collection%E4%BD%93%E7%B3%BB%E5%92%8C%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB/" />
<meta property="article:published_time" content="2019-10-21T22:07:58+08:00" />
<meta property="article:modified_time" content="2019-10-21T22:07:58+08:00" />
<meta itemprop="name" content="Collection体系和常用实现类">
<meta itemprop="description" content="Collection体系和常用实现类  Collection继承体系  // 常用实现: ArrayList List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i&lt; list.size(); i&#43;&#43;) { list.get(i); }  // 常用实现: LinkedHashSet Collect c = new LinkedHashSet(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(c); //等价于 List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); list2.addAll(c); //等价于 List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(); for(Integer i : c){ list3.add(i); } list.add(1); list.add(2); //不停的加  List  最常用的ArrayList  本质上是一个数组  面试题: 动态扩容的实现  创建一个更大的空间, 然后把原先的所有元素拷贝过去    旧的容量=数组的长度">


<meta itemprop="datePublished" content="2019-10-21T22:07:58&#43;08:00" />
<meta itemprop="dateModified" content="2019-10-21T22:07:58&#43;08:00" />
<meta itemprop="wordCount" content="367">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Collection体系和常用实现类"/>
<meta name="twitter:description" content="Collection体系和常用实现类  Collection继承体系  // 常用实现: ArrayList List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i&lt; list.size(); i&#43;&#43;) { list.get(i); }  // 常用实现: LinkedHashSet Collect c = new LinkedHashSet(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(c); //等价于 List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); list2.addAll(c); //等价于 List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(); for(Integer i : c){ list3.add(i); } list.add(1); list.add(2); //不停的加  List  最常用的ArrayList  本质上是一个数组  面试题: 动态扩容的实现  创建一个更大的空间, 然后把原先的所有元素拷贝过去    旧的容量=数组的长度"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://afei.website" class="f3 fw2 hover-white no-underline white-90 dib">
      阿飞的博客
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Collection体系和常用实现类</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-10-21T22:07:58&#43;08:00">October 21, 2019</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h1 id="collection体系和常用实现类">Collection体系和常用实现类</h1>

<ul>
<li>Collection继承体系</li>
</ul>

<p><img src="/images/1571480404514.png" alt="1571480404514" /></p>

<pre><code class="language-java">// 常用实现: ArrayList
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
for(int i = 0; i&lt; list.size(); i++) {
	list.get(i);
}
</code></pre>

<pre><code class="language-java">// 常用实现: LinkedHashSet
Collect c = new LinkedHashSet();

List&lt;Integer&gt; list = new ArrayList&lt;&gt;(c);

//等价于
List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();
list2.addAll(c);

//等价于
List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();
for(Integer i : c){
    list3.add(i);
}

list.add(1);
list.add(2);
//不停的加
</code></pre>

<h2 id="list">List</h2>

<ul>
<li>最常用的ArrayList

<ul>
<li>本质上是一个数组</li>
</ul></li>
<li>面试题: 动态扩容的实现

<ul>
<li>创建一个更大的空间, 然后把原先的所有元素拷贝过去</li>
</ul></li>
</ul>

<p><img src="/images/1571483221425.png" alt="1571483221425" /></p>

<ol>
<li><p>旧的容量=数组的长度</p></li>

<li><p>新的容量=旧的容量*1.5</p></li>

<li><p>如果新的容量小于最小容量,则新的容量=最小容量</p></li>

<li><p>如果新的容量大于最大容量,则新的容量=hugeCapacity</p>

<pre><code>    5. 数组=原先的数组全部拷贝到新容量的空间
</code></pre></li>
</ol>

<h2 id="set">Set</h2>

<ul>
<li><p>不允许有重复元素的集合</p>

<ul>
<li>判断重复: equals方法</li>
</ul></li>

<li><p>自己实现一个Set</p>

<pre><code class="language-java">class MySet{
	List&lt;Integer&gt; elements;
  	
	void add(Object object){
		if(elements.contains(object)){
          return;
      }
      elements.add(object);
	}
}
</code></pre></li>

<li><p>上面这个方法比较低效,因为contains每次都要遍历一遍, hashCode()更高效</p>

<pre><code class="language-java">代码见HashSet
</code></pre></li>

<li><p>hashCode是JAVA世界第二重要的约定</p>

<ul>
<li>同一个对象必须始终返回相同的hashCode</li>
<li>两个对象的equals返回true,必须返回相同的hashCode</li>
<li>两个对象不等,也可能返回相同的hashCode</li>
</ul></li>
</ul>

<h2 id="hashset">HashSet</h2>

<ul>
<li><p>最常用,最高效的Set实现</p></li>

<li><p>实战: HashSet的高效性</p>

<pre><code class="language-java">Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
  
for(int i = 0; i &lt; 1000_0000; i++) {
  set.add(i);
  list.add(i);
}
long t0 = System.nanoTime();
set.contains(9999_9999);
  
long t1 = System.nanoTime();
list.contains(9999_9999);
  
long t2 = System.nanoTime();
  
System.out.println(&quot;set:&quot; + (t1-t0)/1000/1000);
System.out.println(&quot;list:&quot;+ (t2-t0)/1000/1000);
</code></pre></li>
</ul>

<p><img src="/images/1571485500357.png" alt="1571485500357" /></p>

<ul>
<li><p>实战: 使用HashSet对ArrayList去重</p>

<pre><code class="language-java">Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
list.add(2);
list.add(4);
set.addAll(list);
</code></pre></li>
</ul>

<p><img src="/images/1571485462611.png" alt="1571485462611" /></p>

<ul>
<li><p>HashSet是无序的! 如果有需要使用LinkedHashSet</p>

<pre><code class="language-java">Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;();
set.add(4);
set.add(1);
set.add(100);
set.add(-200);
  
for (Integer i : set){
  System.out.println(i);
}
</code></pre></li>
</ul>

<p><img src="/images/1571485224284.png" alt="1571485224284" /></p>

<h2 id="linkedhashset">LinkedHashSet</h2>

<ul>
<li><p>与HashSet的无序比较, LinkedHashSet 保留了插入的顺序</p>

<pre><code class="language-java">public class RemoveDuplicateCharsInString {
  // 修改这个方法使得它能够输出正确结果：
  // 例如，输入aabbcc返回abc
  // 输入ccbbaa返回cba
  // 输入apple返回aple
  public static String removeDuplicateCharsInString(String s) {
      HashSet&lt;Character&gt; charSet = new LinkedHashSet&lt;&gt;();
      for (int i = 0; i &lt; s.length(); i++) {
          charSet.add(s.charAt(i));
      }
  
      String result = &quot;&quot;;
      for (Character ch : charSet) {
          result += ch;
      }
  
      return result;
  }
}
</code></pre>

<pre><code class="language-java">public class RemoveDuplicateCharsInStringTest {
  @Test
  public void test() {
      Assertions.assertEquals(
              &quot;cba&quot;, RemoveDuplicateCharsInString.removeDuplicateCharsInString(&quot;ccbbaa&quot;));
      // 如果用HashSet, 则返回的是&quot;abc&quot;
      Assertions.assertEquals(
              &quot;aple&quot;, RemoveDuplicateCharsInString.removeDuplicateCharsInString(&quot;apple&quot;));
  }
}
</code></pre></li>
</ul>

<h2 id="map">Map</h2>

<ul>
<li>键值对(Key:Value)</li>

<li><p>不允许有重复的键,可以有重复的values</p>

<pre><code class="language-java">Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;PATH&quot;,&quot;1&quot;);
map.put(&quot;AAA&quot;,&quot;2&quot;);

map.get(&quot;PATH&quot;);
Set&lt;String&gt; keyset = map.keySet();
//打印key的集合
System.out.println(keyset);
//打印键和值的集合
for (Map.Entry&lt;String,String&gt; entry : map.entrySet()){
System.out.print(entry.getKey());
System.out.print(&quot;:&quot;)
System.out.print(entry.getValue());
System.out.println();
}
//打印去掉某个key后的key的集合
map.remove(&quot;AAA&quot;);
System.out.println(keyset);
</code></pre></li>
</ul>

<p><img src="/images/1571486318134.png" alt="1571486318134" /></p>

<h2 id="hashmap">HashMap</h2>

<ul>
<li>HashMap的key的Set就是HashSet</li>
<li>HashMap扩容的过程</li>
</ul>

<p><img src="/images/1571486540595.png" alt="1571486540595" /></p>

<ol>
<li><p>当前的size+1大于阈值时, resize()扩容</p></li>

<li><p>将原有的HashMap都复制到新的容量空间</p></li>

<li><p>HashMap同一个HashCoe的链表元素个数超过8, 链表-&gt;红黑二叉树树结构</p></li>
</ol>

<p><img src="/images/1571486953542.png" alt="1571486953542" /></p>

<h2 id="hashmap死循环">HashMap死循环</h2>

<p>HashMap多线程下扩容时可能变成死循环链表, 线程不安全</p>

<p><a href="https://coolshell.cn/articles/9606.html">coolshell-HashMap死循环</a></p>

<p><img src="/images/1571486735903.png" alt="1571486735903" /></p>

<p><strong>解决方法 : 用ConcurrentHashMap</strong></p>

<h2 id="有序集合treeset-treemap">有序集合TreeSet/TreeMap</h2>

<ul>
<li><p>二叉树/红黑树简介</p></li>

<li><p>使用Comparable约定, 认为排序相等的元素相等</p></li>

<li><p>二叉树查找, 插入简介</p>

<pre><code class="language-java">      List&lt;Integer&gt; list = Arrays.asList(10000,196,2,-33454534,323232,15);
      Set set1 = new HashSet(list);
      set1.forEach(System.out::println);
      System.out.println(&quot;-----------------&quot;);
      Set set2 = new LinkedHashSet(list);
      set2.forEach(System.out::println);
      System.out.println(&quot;-----------------&quot;);
      Set set3 = new TreeSet(list);
      set3.forEach(System.out::println);
      System.out.println(&quot;-----------------&quot;);
</code></pre>

<pre><code class="language-reStructuredText">10000
2
196
323232
-33454534
15
-----------------
10000
196
2
-33454534
323232
15
-----------------
-33454534
2
15
196
10000
323232
-----------------
</code></pre></li>
</ul>

<p><img src="/images/1571487883906.png" alt="1571487883906" /></p>

<p><strong>ArrayList 和 TreeSet在查找的时间复杂度有很大的差距</strong></p>

<p><img src="/images/1571487976405.png" alt="1571487976405" /></p>

<p><img src="/images/1571488082775.png" alt="1571488082775" /></p>

<p>二叉树翻转:</p>

<p><img src="/images/1571488159248.png" alt="1571488159248" /></p>

<h2 id="collections工具方法">Collections工具方法</h2>

<ul>
<li>emptySet(): 等返回一个方便的空集合</li>
<li>sychronizedCollection: 将一个集合变成线程安全的</li>
<li>unmodifiableCollection: 将一个集合编程不可变的</li>
</ul>

<p><img src="/images/1571488237748.png" alt="1571488237748" /></p>

<p>上述代码把set1变成一个不可变集合</p>

<h2 id="collection不常见的实现">Collection不常见的实现</h2>

<ul>
<li>Queue/ Deque</li>
<li><del>Stack</del></li>
<li>LinkedList</li>
<li>ConcurrentHashMap</li>
<li>PriorityQueue</li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://afei.website" >
    &copy; 2019 阿飞的博客
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
